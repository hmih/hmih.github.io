<!DOCTYPE html>
<html lang="en">
<head>
      <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Thoughts</title>
  <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
  <link rel="stylesheet" href="./theme/css/main.css" type="text/css" />
  <link rel="preload" href="./fonts/et-bembo-roman-line-figures/et-bembo-roman-line-figures.woff" as="font" type="font/woff" crossorigin>
  <link rel="canonical" href="./web-intefaces.html">
  <meta name="author" content="Hristo Mihaylov" />
  <meta name="title" content="" />
  <meta name="description" content="out of the tar pit" />

    <meta property="og:type" content="article">
    <meta property="article:published_time" content="2023-04-13T11:30:00.000000">
    <meta property="article:author" content="Hristo Mihaylov" />
</head>
<body>
  <aside id="asidebar">
    <nav class="main-menu">
      <ul>
        <li><a href="./">Home</a></li>
      </ul>
    </nav>

    <ul id="social">
      <li><a href="https://github.com/hmih" title="GitHub" target=_blank rel="noopener"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4wMQBSkoPIUbOQAAAWNJREFUOMuVk7FKQzEUhr970UmXDklG26UKFfUFFCm+gopTJx0UHOpWfAAdHBx00CfQDvoAHUR0FRSk6NI6JpkEnapel3NLCLXUA4F7kv//85+TcxMkjNJY7zBKV4A9YBmYkuM34AY4st4951iAJCJfAGsMj0vr3XrOSQLyC1BmtHi13k0bpUmF3BTyE1ADugJ8l4Xs1QRTNko3cwdzwKOAzq13W8OuNkqfAZuSzqdAPTgfG8F+iKknRulu0O1J4DPv8IDbASaAj/x1EqP0j7zGl/VufJQOGqV74iRLgewf9uMyshToBMpVsflnCUbparDVSYFW4OIaKEaEUKMIXAV5KzFKF8XFPlABNoAHYNd6dy9CS8AxsBCZKuWjfAJsA7PyH5SAFeA7qLkXkU+tdzvhKN8CM8Aq4Kx37aj+LEjvrHeL/fLyD6P0gVE6i8B9AVmHISceEozSBaN0Y4BAwyhdiMm/6K92B5mUXmkAAAAASUVORK5CYII=" alt="GitHub"></a></li>
    </ul>
  </aside>
  <main>            <article>
                <header>
                  <h1>
                    <a href="./web-intefaces.html">Web Intefaces</a>
                  </h1>

                  <p><span class="newthought">April 13, 2023</span></p>
                </header>

                <p>What is the high-level architecture behind a typical CRUD web application?</p>
<div class="section" id="rest">
<h2>REST</h2>
<object data="/images/rest-schema-crud.svg" type="image/svg+xml">Typical REST architecture with a SPA and a relational database</object>
<p>In the diagram we see the following:</p>
<ul class="simple">
<li>UI has a set of DTOs that are presented to the customer.</li>
<li>REST endpoints are an informal interface between the UI and the server.</li>
<li>Backend has a set of DTOs that both validate the data from the UI and
transform the inputs into a suitable form for the relational database.</li>
<li>The schema of the database contains for the final result from the client
interaction.</li>
</ul>
<p>There are several components to keep in sync, otherwise the application will
crash at runtime:</p>
<ol class="arabic simple">
<li>REST interface - This is the router exposed by the backend and consumed by
the facade. Almost always these are two sets of strings that must be kept in
sync. Add a slash, parameter, or letter to one but forget the other and you
will be sent to the JIRA mines.</li>
<li>DTOs - There are two sets of objects to synchronize. Even more room for
entity definitions to drift or accrue edge case logic that results in
special handling of values that are externally insible to <em>any</em> of the
<em>three</em> sides.</li>
<li>Relational Schema - The source of truth, or so we think. It's completely
disconnected from the other two sets of entities and the exposed router.</li>
</ol>
<p>What are the alternatives?</p>
</div>
<div class="section" id="grpc">
<h2>gRPC</h2>
<object data="/images/grpc-schema-crud.svg" type="image/svg+xml">gRPC based service that shares DTOs with the facade and the backend</object>
<p>I have written several gRPC-based CRUD applications that use a Protobuf
definition to generate: 1) DTOs for the facade, 2) DTOs the backend, 3) routing
layer between the two. This is a good solution to entity drift and
synchronization. The database can immediately map rows into DTOs that get
filterd and sent directly to the UI. The additional benefit of this is not
writing your own router. Just through auto-completion you will get type safe
routes that will never request a non-existing endpoint.</p>
<p>However, the database schema might drift, so Protobuf messages must be kept
synchronized with the database columns and types. The problem is that Protobuf
is not suited for relational data. The format lacks the semantics to express
the intent. The issue is fundamental to mapping relational to non-relational
data. Perhaps the code-first approach has run its course.</p>
<p>What if we start from the database?</p>
</div>
<div class="section" id="postgrest">
<h2>PostgREST</h2>
<p>PostgREST is a program that runs on top of a PostgreSQL database and exposes
the schema as a set of REST API endpoints. Having written a PostgREST-based
service that constructs and analyzes time series data I can say it works very
well. There is no backend synchronization to keep track of, and there is an
option to expose an OpenAPI specification from the REST API. This allows the
client to construct a router with DTOs on demand, meaning that we get a type
safe router.</p>
<object data="/images/postgrest-schema-rest.svg" type="image/svg+xml">PostgREST architecture</object>
<p>There is a whole section in the PostgREST documentation about authentication,
security, users, etc. But they've thought about it and it's impressive how I
was able to push the product using stored procedures and basic SQL.</p>
<p>My only issue is that stored procedures are not very popular. Writing out your
backend logic in a language few people get and maintain will cause headaches
down the road. It would be easier to handle some of the essential business
logic in a regular programming language like C# or Python. Luckily PostgreSQL
has several plugin which allow writing stored procedures in your language of
choice.</p>
<p>What about versioning? How about unit testing? Well, I never wrote any
¯\_(ツ)_/¯ Nothing captures the adrenaline rush of executing destructive
queries on production. You think to yourself: &quot;Did I put this in a
transaction?&quot;. Those were the days.</p>
</div>

            </article>
  </main>
</body>
</html>